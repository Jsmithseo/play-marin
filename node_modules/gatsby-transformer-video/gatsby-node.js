"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _path = require("path");

var _os = _interopRequireDefault(require("os"));

var _fsExtra = require("fs-extra");

var _graphql = require("gatsby/graphql");

var _ffmpeg = _interopRequireDefault(require("./ffmpeg"));

var _binaries = require("./binaries");

const platform = _os.default.platform();

const arch = _os.default.arch();

const CACHE_FOLDER_BIN = (0, _path.resolve)(`node_modules`, `.cache`, `gatsby-transformer-video-bin`, `${platform}-${arch}`);
const CACHE_FOLDER_VIDEOS = (0, _path.resolve)(`node_modules`, `.cache`, `gatsby-transformer-video`);

class WrongFileTypeError extends Error {}

const DEFAULT_ARGS = {
  maxWidth: {
    type: _graphql.GraphQLInt,
    defaultValue: 1920
  },
  maxHeight: {
    type: _graphql.GraphQLInt,
    defaultValue: null
  },
  duration: {
    type: _graphql.GraphQLInt,
    defaultValue: null
  },
  fps: {
    type: _graphql.GraphQLInt,
    defaultValue: null
  },
  saturation: {
    type: _graphql.GraphQLFloat,
    defaultValue: 1
  },
  overlay: {
    type: _graphql.GraphQLString,
    defaultValue: null
  },
  overlayX: {
    type: _graphql.GraphQLString,
    defaultValue: `center`
  },
  overlayY: {
    type: _graphql.GraphQLString,
    defaultValue: `center`
  },
  overlayPadding: {
    type: _graphql.GraphQLInt,
    defaultValue: 10
  },
  publicPath: {
    type: _graphql.GraphQLString,
    defaultValue: `assets/videos`
  },
  screenshots: {
    type: _graphql.GraphQLString
  },
  screenshotWidth: {
    type: _graphql.GraphQLInt,
    defaultValue: 600
  }
};

exports.createSchemaCustomization = ({
  actions,
  schema
}) => {
  const {
    createTypes
  } = actions;
  const typeDefs = [schema.buildObjectType({
    name: `GatsbyVideo`,
    fields: {
      path: _graphql.GraphQLString,
      absolutePath: _graphql.GraphQLString,
      name: _graphql.GraphQLString,
      ext: _graphql.GraphQLString,
      codec: _graphql.GraphQLString,
      formatName: _graphql.GraphQLString,
      formatLongName: _graphql.GraphQLString,
      startTime: _graphql.GraphQLFloat,
      duration: _graphql.GraphQLFloat,
      size: _graphql.GraphQLInt,
      bitRate: _graphql.GraphQLInt,
      screenshots: `[GatsbyVideoScreenshot]`
    }
  }), schema.buildObjectType({
    name: `GatsbyVideoScreenshot`,
    fields: {
      path: _graphql.GraphQLString,
      absolutePath: _graphql.GraphQLString
    }
  })];
  createTypes(typeDefs);
};

exports.createResolvers = async ({
  createResolvers,
  store
}, {
  ffmpegPath,
  ffprobePath,
  downloadBinaries = true,
  profiles = {}
}) => {
  const program = store.getState().program;
  const rootDir = program.directory;
  const cacheDirOriginal = (0, _path.resolve)(rootDir, CACHE_FOLDER_VIDEOS, `original`);
  const cacheDirConverted = (0, _path.resolve)(rootDir, CACHE_FOLDER_VIDEOS, `converted`);
  await (0, _fsExtra.ensureDir)(cacheDirOriginal);
  await (0, _fsExtra.ensureDir)(cacheDirConverted);
  const alreadyInstalled = await (0, _binaries.libsInstalled)({
    platform
  }); // Set paths to our own binaries

  if (!alreadyInstalled && downloadBinaries && (!ffmpegPath || !ffprobePath)) {
    ffmpegPath = (0, _path.resolve)(rootDir, CACHE_FOLDER_BIN, `ffmpeg${platform === `win32` ? `.exe` : ``}`);
    ffprobePath = (0, _path.resolve)(rootDir, CACHE_FOLDER_BIN, `ffprobe${platform === `win32` ? `.exe` : ``}`);
  }

  const ffmpeg = new _ffmpeg.default({
    rootDir,
    cacheDirOriginal,
    cacheDirConverted,
    ffmpegPath,
    ffprobePath,
    profiles
  }); // Get source videos metadata and download the file if required

  async function prepareAndAnalyzeVideo({
    video,
    fieldArgs
  }) {
    const {
      type
    } = video.internal;
    let fileType = null;

    if (type === `File`) {
      fileType = video.internal.mediaType;
    }

    if (type === `ContentfulAsset`) {
      fileType = video.file.contentType;
    }

    if (!fileType) {
      throw new Error(`Unable to extract asset file type for ${type} (${video.id})`);
    }

    if (fileType.indexOf(`video/`) === -1) {
      throw new WrongFileTypeError();
    }

    const metadata = await ffmpeg.analyzeVideo({
      video,
      fieldArgs,
      type
    });

    if (!metadata) {
      throw new Error(`Unable to read metadata from:\n\n${JSON.stringify(video, null, 2)}`);
    }

    const {
      path,
      filename: name,
      info
    } = metadata;
    const publicDir = (0, _path.resolve)(rootDir, `public`, fieldArgs.publicPath);
    await (0, _fsExtra.ensureDir)(publicDir);
    return {
      publicDir,
      path,
      name,
      info
    };
  } // Analyze the resulting video and prepare field return values


  async function processResult({
    publicPath,
    screenshots
  }) {
    const result = await ffmpeg.executeFfprobe(publicPath);
    const {
      format_name: formatName,
      format_long_name: formatLongName,
      start_time: startTime,
      duration: duration,
      size: size,
      bit_rate: bitRate
    } = result.format;
    const path = publicPath.replace((0, _path.resolve)(rootDir, `public`), ``);
    const {
      name,
      ext
    } = (0, _path.parse)(publicPath);
    return {
      path,
      absolutePath: publicPath,
      name,
      ext,
      formatName,
      formatLongName,
      startTime: startTime === `N/A` ? null : startTime,
      duration: duration === `N/A` ? null : duration,
      size: size === `N/A` ? null : size,
      bitRate: bitRate === `N/A` ? null : bitRate,
      screenshots
    };
  } // Transform video with a given transformer & codec


  function transformVideo({
    transformer
  }) {
    return async (video, fieldArgs) => {
      try {
        const {
          publicDir,
          path,
          name,
          info
        } = await prepareAndAnalyzeVideo({
          video,
          fieldArgs
        });
        const videoData = await transformer({
          publicDir,
          path,
          name,
          fieldArgs,
          info
        });
        return await processResult(videoData);
      } catch (err) {
        if (!(err instanceof WrongFileTypeError)) {
          throw err;
        }

        return null;
      }
    };
  }

  const videoFields = {
    videoH264: {
      type: `GatsbyVideo`,
      args: { ...DEFAULT_ARGS,
        crf: {
          type: _graphql.GraphQLInt,
          defaultValue: 31
        },
        preset: {
          type: _graphql.GraphQLString,
          defaultValue: `superfast`
        },
        maxRate: {
          type: _graphql.GraphQLString
        },
        bufSize: {
          type: _graphql.GraphQLString
        }
      },
      resolve: transformVideo({
        transformer: ffmpeg.createH264
      })
    },
    videoH265: {
      type: `GatsbyVideo`,
      args: { ...DEFAULT_ARGS,
        crf: {
          type: _graphql.GraphQLInt,
          defaultValue: 36
        },
        preset: {
          type: _graphql.GraphQLString,
          defaultValue: `superfast`
        },
        maxRate: {
          type: _graphql.GraphQLInt
        },
        bufSize: {
          type: _graphql.GraphQLInt
        }
      },
      resolve: transformVideo({
        transformer: ffmpeg.createH265
      })
    },
    videoVP9: {
      type: `GatsbyVideo`,
      args: { ...DEFAULT_ARGS,
        crf: {
          type: _graphql.GraphQLInt,
          defaultValue: 31
        },
        bitrate: {
          type: _graphql.GraphQLString
        },
        minrate: {
          type: _graphql.GraphQLString
        },
        maxrate: {
          type: _graphql.GraphQLString
        },
        cpuUsed: {
          type: _graphql.GraphQLInt,
          defaultValue: 1
        }
      },
      resolve: transformVideo({
        transformer: ffmpeg.createVP9
      })
    },
    videoWebP: {
      type: `GatsbyVideo`,
      args: { ...DEFAULT_ARGS
      },
      resolve: transformVideo({
        transformer: ffmpeg.createWebP
      })
    },
    videoGif: {
      type: `GatsbyVideo`,
      args: { ...DEFAULT_ARGS
      },
      resolve: transformVideo({
        transformer: ffmpeg.createGif
      })
    },
    videoProfile: {
      type: `GatsbyVideo`,
      args: {
        profile: {
          type: _graphql.GraphQLString
        },
        ...DEFAULT_ARGS
      },
      resolve: transformVideo({
        transformer: ffmpeg.createFromProfile
      })
    }
  };
  const resolvers = {
    ContentfulAsset: videoFields,
    File: videoFields
  };
  createResolvers(resolvers);
};

exports.onPreInit = async ({
  store
}, {
  downloadBinaries = true
}) => {
  if (!downloadBinaries) {
    console.log(`Skipped download of FFMPEG & FFPROBE binaries`);
    return;
  }

  const alreadyInstalled = await (0, _binaries.libsInstalled)({
    platform
  });

  if (alreadyInstalled) {
    console.log(`FFMPEG && FFPROBE are already available on this machine`);
    return;
  }

  const arch = _os.default.arch();

  const program = store.getState().program;
  const rootDir = program.directory;
  const binariesDir = (0, _path.resolve)(rootDir, CACHE_FOLDER_BIN);

  try {
    await (0, _binaries.libsAlreadyDownloaded)({
      binariesDir
    });
    console.log(`FFMPEG & FFPROBE binaries already downloaded`);
  } catch {
    try {
      console.log(`FFMPEG & FFPROBE getting binaries for ${platform}@${arch}`);
      await (0, _binaries.downloadLibs)({
        binariesDir,
        platform
      });
      console.log(`Finished. This system is ready to convert videos with GatsbyJS`);
    } catch (err) {
      throw err;
    }
  }
};