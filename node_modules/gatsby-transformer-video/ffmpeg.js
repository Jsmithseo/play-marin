"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _path = require("path");

var _perf_hooks = require("perf_hooks");

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _fsExtra = require("fs-extra");

var _fluentFfmpeg = _interopRequireDefault(require("fluent-ffmpeg"));

var _fastGlob = _interopRequireDefault(require("fast-glob"));

var _imagemin = _interopRequireDefault(require("imagemin"));

var _imageminGiflossy = _interopRequireDefault(require("imagemin-giflossy"));

var _imageminMozjpeg = _interopRequireDefault(require("imagemin-mozjpeg"));

var _pQueue = _interopRequireDefault(require("p-queue"));

var _sharp = _interopRequireDefault(require("sharp"));

var _helpers = require("./helpers");

var _h = _interopRequireDefault(require("./profiles/h264"));

var _h2 = _interopRequireDefault(require("./profiles/h265"));

var _vp = _interopRequireDefault(require("./profiles/vp9"));

var _webp = _interopRequireDefault(require("./profiles/webp"));

var _gif = _interopRequireDefault(require("./profiles/gif"));

class FFMPEG {
  constructor({
    rootDir,
    cacheDirOriginal,
    cacheDirConverted,
    ffmpegPath,
    ffprobePath,
    profiles
  }) {
    (0, _defineProperty2.default)(this, "executeFfprobe", path => new Promise((resolve, reject) => {
      (0, _fluentFfmpeg.default)(path).ffprobe((err, data) => {
        if (err) reject(err);
        resolve(data);
      });
    }));
    (0, _defineProperty2.default)(this, "executeFfmpeg", async ({
      ffmpegSession,
      cachePath,
      loggingPrefix
    }) => {
      let startTime;
      let lastLoggedPercent = 0.1;
      return new Promise((resolve, reject) => {
        ffmpegSession.on(`start`, commandLine => {
          console.log(`${loggingPrefix} Executing:\n\n${commandLine}\n`);
          startTime = _perf_hooks.performance.now();
        }).on(`progress`, progress => {
          if (progress.percent > lastLoggedPercent + 10) {
            const percent = Math.floor(progress.percent);
            const elapsedTime = Math.ceil((_perf_hooks.performance.now() - startTime) / 1000);
            const estTotalTime = 100 / percent * elapsedTime;
            const estTimeLeft = Math.ceil(estTotalTime - elapsedTime);
            const loggedTimeLeft = estTimeLeft !== Infinity && ` (~${estTimeLeft}s)`;
            console.log(`${loggingPrefix} ${percent}%${loggedTimeLeft}`);
            lastLoggedPercent = progress.percent;
          }
        }).on(`error`, (err, stdout, stderr) => {
          console.log(`\n---\n`, stdout, stderr, `\n---\n`);
          console.log(`${loggingPrefix} An error occurred:`);
          console.error(err);
          reject(err);
        }).on(`end`, () => {
          console.log(`${loggingPrefix} 100%`);
          resolve();
        }).save(cachePath);
      });
    });
    (0, _defineProperty2.default)(this, "analyzeVideo", async ({
      video,
      fieldArgs,
      type
    }) => {
      let path;
      let contentDigest = video.internal.contentDigest;

      if (type === `File`) {
        path = video.absolutePath;
      }

      if (type === `ContentfulAsset`) {
        path = await (0, _helpers.cacheContentfulVideo)({
          video,
          cacheDir: this.cacheDirOriginal
        });
        contentDigest = (0, _gatsbyCoreUtils.createContentDigest)([video.contentful_id, video.file.url, video.file.details.size]);
      }

      if (!path) {
        throw new Error(`Unable to extract asset file path for ${type} (${video.id})`);
      }

      const optionsHash = (0, _gatsbyCoreUtils.createContentDigest)(fieldArgs);
      const filename = `${contentDigest}-${optionsHash}`;
      const info = await this.executeFfprobe(path);
      return {
        path,
        filename,
        info
      };
    });
    (0, _defineProperty2.default)(this, "convertVideo", async (...args) => {
      const videoData = await this.queue.add(() => this.queuedConvertVideo(...args));
      return videoData;
    });
    (0, _defineProperty2.default)(this, "queuedConvertVideo", async ({
      profile,
      sourcePath,
      cachePath,
      publicPath,
      fieldArgs,
      info
    }) => {
      const alreadyExists = await (0, _fsExtra.pathExists)(cachePath);

      if (!alreadyExists) {
        const loggingPrefix = `[FFMPEG]`;
        const ffmpegSession = (0, _fluentFfmpeg.default)().input(sourcePath);
        const filters = this.createFilters({
          fieldArgs,
          info
        }).join(`,`);
        const videoStreamMetadata = this.parseVideoStream(info.streams);
        profile({
          ffmpegSession,
          filters,
          fieldArgs,
          videoStreamMetadata
        });
        this.enhanceFfmpegForFilters({
          ffmpegSession,
          fieldArgs
        });
        await this.executeFfmpeg({
          ffmpegSession,
          cachePath,
          loggingPrefix
        });
      } // If public file does not exist, copy cached file


      const publicExists = await (0, _fsExtra.pathExists)(publicPath);

      if (!publicExists) {
        await (0, _fsExtra.copy)(cachePath, publicPath);
      } // Check if public and cache file vary in size


      const cacheFileStats = await (0, _fsExtra.stat)(cachePath);
      const publicFileStats = await (0, _fsExtra.stat)(publicPath);

      if (publicExists && cacheFileStats.size !== publicFileStats.size) {
        await (0, _fsExtra.copy)(cachePath, publicPath, {
          overwrite: true
        });
      } // Take screenshots


      const screenshots = await this.takeScreenshots({
        fieldArgs,
        publicPath
      });
      return {
        screenshots,
        publicPath
      };
    });
    (0, _defineProperty2.default)(this, "takeScreenshots", async ({
      fieldArgs,
      publicPath
    }) => {
      const {
        screenshots,
        screenshotWidth
      } = fieldArgs;
      console.log({
        screenshots
      });

      if (!screenshots) {
        return null;
      }

      const {
        dir: publicDir,
        name
      } = (0, _path.parse)(publicPath);
      const screenshotPatternCache = (0, _path.resolve)(this.cacheDirConverted, `${name}-screenshot-*.png`);
      const screenshotPatternPublic = (0, _path.resolve)(publicDir, `${name}-screenshot-*.jpg`);
      const screenshotsCache = await (0, _fastGlob.default)([screenshotPatternCache]);
      const screenshotsPublic = await (0, _fastGlob.default)([screenshotPatternPublic]);

      if (!screenshotsCache.length) {
        const timestamps = screenshots.split(`,`);
        await new Promise((resolve, reject) => {
          (0, _fluentFfmpeg.default)(publicPath).on(`filenames`, function (filenames) {
            console.log(`[FFMPEG] Taking ${filenames.length} screenshots`);
          }).on(`error`, (err, stdout, stderr) => {
            console.log(`[FFMPEG] Failed to take screenshots:`);
            console.error(err);
            reject(err);
          }).on(`end`, () => {
            resolve();
          }).screenshots({
            timestamps,
            filename: `${name}-screenshot-%ss.png`,
            folder: this.cacheDirConverted,
            size: `${screenshotWidth}x?`
          });
        });
      }

      if (!screenshotsPublic.length) {
        const screenshotsLatest = await (0, _fastGlob.default)([screenshotPatternCache]);

        for (const rawScreenshotPath of screenshotsLatest) {
          const {
            name: screenshotName
          } = (0, _path.parse)(rawScreenshotPath);
          const publicScreenshotPath = (0, _path.resolve)(publicDir, `${screenshotName}.jpg`);

          try {
            const jpgBuffer = await (0, _sharp.default)(rawScreenshotPath).jpeg({
              quality: 60,
              progressive: true
            }).toBuffer();
            const optimizedBuffer = await _imagemin.default.buffer(jpgBuffer, {
              plugins: [(0, _imageminMozjpeg.default)()]
            });
            await (0, _fsExtra.writeFile)(publicScreenshotPath, optimizedBuffer);
          } catch (err) {
            console.log(`Unable to convert png screenshots to jpegs`);
            throw err;
          }
        }

        console.log(`[FFMPEG] Finished copying screenshots`);
      }

      const latestFiles = await (0, _fastGlob.default)([screenshotPatternPublic]);
      return latestFiles.map(absolutePath => {
        return {
          absolutePath,
          path: absolutePath.replace((0, _path.resolve)(this.rootDir, `public`), ``)
        };
      });
    });
    (0, _defineProperty2.default)(this, "createFromProfile", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const profileName = fieldArgs.profile;
      const profile = this.profiles[profileName];

      if (!profile) {
        throw new Error(`Unable to locate FFMPEG profile ${profileName}`);
      }

      if (!profile.extension) {
        throw new Error(`FFMPEG profile ${profileName} has no extension specified`);
      }

      if (!profile.converter) {
        throw new Error(`FFMPEG profile ${profileName} has no converter function specified`);
      }

      const filename = `${name}-${profileName}.${profile.extension}`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      return this.convertVideo({
        profile: profile.converter,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
    });
    (0, _defineProperty2.default)(this, "createH264", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const filename = `${name}-h264.mp4`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      return this.convertVideo({
        profile: _h.default,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
    });
    (0, _defineProperty2.default)(this, "createH265", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const filename = `${name}-h265.mp4`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      return this.convertVideo({
        profile: _h2.default,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
    });
    (0, _defineProperty2.default)(this, "createVP9", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const filename = `${name}-vp9.webm`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      return this.convertVideo({
        profile: _vp.default,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
    });
    (0, _defineProperty2.default)(this, "createWebP", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const filename = `${name}-webp.webp`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      return this.convertVideo({
        profile: _webp.default,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
    });
    (0, _defineProperty2.default)(this, "createGif", async ({
      publicDir,
      path,
      name,
      fieldArgs,
      info
    }) => {
      const filename = `${name}-gif.gif`;
      const cachePath = (0, _path.resolve)(this.cacheDirConverted, filename);
      const publicPath = (0, _path.resolve)(publicDir, filename);
      const absolutePath = await this.convertVideo({
        profile: _gif.default,
        sourcePath: path,
        cachePath,
        publicPath,
        fieldArgs,
        info
      });
      await (0, _imagemin.default)([publicPath], {
        destination: publicDir,
        plugins: [(0, _imageminGiflossy.default)({
          optimizationLevel: 3,
          lossy: 120,
          noLogicalScreen: true,
          optimize: `3`
        })]
      });
      return absolutePath;
    });
    (0, _defineProperty2.default)(this, "createFilters", ({
      fieldArgs,
      info
    }) => {
      const {
        maxWidth,
        maxHeight,
        duration,
        fps,
        saturation,
        overlay,
        overlayX,
        overlayY,
        overlayPadding
      } = fieldArgs;
      const filters = [];
      const {
        duration: sourceDuration
      } = info.streams[0];

      if (duration) {
        filters.push(`setpts=${(duration / sourceDuration).toFixed(6)}*PTS`);
      }

      if (fps) {
        filters.push(`fps=${fps}`);
      }

      if (maxWidth || maxHeight) {
        filters.push(`scale=${this.generateScaleFilter({
          maxWidth,
          maxHeight
        })}`);
      }

      if (saturation !== 1) {
        filters.push(`eq=saturation=${saturation}`);
      }

      if (overlay) {
        const padding = overlayPadding === undefined ? 10 : overlayPadding;
        let x = overlayX === undefined ? `center` : overlayX;
        let y = overlayY === undefined ? `center` : overlayY;

        if (x === `start`) {
          x = padding;
        }

        if (x === `center`) {
          x = `(main_w-overlay_w)/2`;
        }

        if (x === `end`) {
          x = `main_w-overlay_w-${padding}`;
        }

        if (y === `start`) {
          y = padding;
        }

        if (y === `center`) {
          y = `(main_h-overlay_h)/2`;
        }

        if (y === `end`) {
          y = `main_h-overlay_h-${padding}`;
        }

        filters.push(`overlay=x=${x}:y=${y}`);
      }

      return filters;
    });
    (0, _defineProperty2.default)(this, "enhanceFfmpegForFilters", ({
      fieldArgs: {
        overlay,
        duration
      },
      ffmpegSession
    }) => {
      if (duration) {
        ffmpegSession.duration(duration).noAudio();
      }

      if (overlay) {
        const path = (0, _path.resolve)(this.rootDir, overlay);
        ffmpegSession.input(path);
      }
    });
    (0, _defineProperty2.default)(this, "parseVideoStream", streams => {
      const videoStream = streams.find(stream => stream.codec_type === `video`);
      const currentFps = parseInt(videoStream.r_frame_rate.split(`/`)[0]);
      return {
        videoStream,
        currentFps
      };
    });
    this.queue = new _pQueue.default({
      concurrency: 1
    });
    this.cacheDirOriginal = cacheDirOriginal;
    this.cacheDirConverted = cacheDirConverted;
    this.rootDir = rootDir;
    this.profiles = profiles;

    if (ffmpegPath) {
      _fluentFfmpeg.default.setFfmpegPath(ffmpegPath);
    }

    if (ffprobePath) {
      _fluentFfmpeg.default.setFfprobePath(ffprobePath);
    }
  } // Execute FFPROBE and return metadata


  // Create scale filter based on given field args
  generateScaleFilter({
    maxWidth,
    maxHeight
  }) {
    if (!maxHeight) {
      return `'min(${maxWidth},iw)':-2:flags=lanczos`;
    }

    return `'min(iw*min(1\\,min(${maxWidth}/iw\\,${maxHeight}/ih)), iw)':-2:flags=lanczos`;
  } // Locates video stream and returns metadata


}

exports.default = FFMPEG;